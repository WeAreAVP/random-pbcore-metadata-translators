<?xml version="1.0"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:mt="http://www.iana.org/assignments/media-types/" xmlns:la="http://www.loc.gov/standards/iso639-2/" xmlns:str="http://exslt.org/strings" extension-element-prefixes="str" xmlns="http://www.pbcore.org/PBCore/PBCoreNamespace.html" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<xsl:output encoding="UTF-8" method="xml" version="1.0" indent="yes"/>

<!--
Title: mediainfo2pbcoreinstantiation.xsl
Version: 0.4
Based on Mediainfo version 0.7.38
Based on PBCore version 2.0RC1

	Â© 2010 AudioVisual Preservation Solutions
	Created to transform XML output of MediaInfo (http://mediainfo.sourceforge.net by MediaArea, SARL) to an instantiation element of a PBCore 1.2.1 record (http://www.pbcore.org). The translation expects that MediaInfo be operated with the '-f', '__Language=Raw', and '__Output=XML' options (change double-underscores to double-hyphens). The translation is customized for mediainfo version 0.7.27 and may provide unexpected results with any other version of mediainfo.
		
	Updated for use with the Secure Media Network of the Dance Heritage Coalition, September 2009 and January 2011.

	This work employs PBCore. The PBCore (Public Broadcasting Metadata Dictionary) was created by the public broadcasting community in the United States of America for use by public broadcasters and others. Initial development funding for PBCore was provided by the Corporation for Public Broadcasting. The PBCore is built on the foundation of the Dublin Core (ISO 15836), an international standard for resource discovery (http://dublincore.org), and has been reviewed by the Dublin Core Metadata Initiative Usage Board. Copyright: 2005, Corporation for Public Broadcasting. 

Versions:

0.1.1 initial release
0.2   added fileextension to instantiationIdentifier where instantiationIdentifierSource is 'File Name'
	  updated from MediaInfo 0.7.27 to 0.7.32, see http://mediainfo.sourceforge.net/Log
		- this update allows the removal of the iso 639-1 to 639-2 lookup table

		
		Example use:
		
		a. generate mediainfo.xml (change double-underscore to double-hyphen)
		
		   mediainfo -f __Language=raw __Output=XML file.mov > mediainfo.xml
		
		b. use mediainfo_2_pbcore_inst.xsl to transform mediainfo.xml to pbcore.xml
		
		   xsltproc mediainfo2pbcoreinstantiation.xsl mediainfo.xml > pbcore.xml
		   
		Or as one line:
		
		   mediainfo __Language=raw -f __Output=XML file.mov > mediainfo.xml && xsltproc mediainfo2pbcoreinstantiation.xsl mediainfo.xml > pbcore.xml
-->
	<xsl:template match="Mediainfo">
		<xsl:variable name="mediainfoSource">MediaInfoLib</xsl:variable>
		<xsl:variable name="mediainfoVersion"><xsl:value-of select="@version"/></xsl:variable>
		<pbcoreInstantiationDocument>
			<xsl:choose>
				<xsl:when test="count(File)>1">
		   			<instantiationID>
			   			<instantiationIdentifier>Test</instantiationIdentifier>
			   			<instantiationIdentifierSource>Test</instantiationIdentifierSource>
			   		</instantiationID>
			   		<formatLocation>Test</formatLocation>
			   		<xsl:for-each select="File">
				   		<instantiationPart>
					   		<xsl:apply-templates select="."/>
				   		</instantiationPart>
			   		</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<xsl:apply-templates select="File"/>
				</xsl:otherwise>
			</xsl:choose>
		</pbcoreInstantiationDocument>
	</xsl:template>
	<xsl:template match="File">
		<xsl:variable name="mediainfoSource">MediaInfoLib</xsl:variable>
		<xsl:variable name="mediainfoVersion"><xsl:value-of select="../@version"/></xsl:variable>
			<xsl:comment> generated by mediainfo2pbcoreinstantiation.xsl ; version 0.1.2 ; based on MediaInfoLib - v0.7.37; www.avpreserve.com </xsl:comment>			
			<xsl:for-each select="track[@type='General']">
				<!-- instantiationIdentifier/instantiationIdentifierSource -->
				<xsl:if test="FileName">
					<instantiationIdentifier>
						<xsl:attribute name="source">File Name</xsl:attribute>
						<xsl:value-of select="FileName"/>
						<xsl:if test="FileExtension">
							<xsl:text>.</xsl:text><xsl:value-of select="FileExtension"/>
						</xsl:if>
					</instantiationIdentifier>
				</xsl:if>
				<xsl:for-each select="str:tokenize(Media_UUID, '/')"><!-- this matches on the 'uuid' element in Final Cut XML Interchange Format-->
					<instantiationIdentifier>
						<xsl:attribute name="source">com.apple.finalcutstudio.media.uuid</xsl:attribute>
						<xsl:value-of select="normalize-space(.)"/>
					</instantiationIdentifier>
				</xsl:for-each>
				<!-- dates -->
				<xsl:for-each select="Encoded_Date | Tagged_Date | File_Modified_Date | Mastered_Date | Recorded_Date | Released_Date">
					<instantiationDate>
						<xsl:attribute name="dateType">
							<xsl:value-of select="translate(local-name(),'_',' ')"/>
   						</xsl:attribute>
						<xsl:choose>
							<xsl:when test="substring(.,1,3)='UTC' and string-length(.)='23'">
								<xsl:value-of select="substring(.,5,10)"/><xsl:text>T</xsl:text><xsl:value-of select="substring(.,16,8)"/><xsl:text>Z</xsl:text>
							</xsl:when>
							<xsl:when test="string-length(.)='19'">
								<xsl:value-of select="substring(.,1,10)"/><xsl:text>T</xsl:text><xsl:value-of select="substring(.,12,8)"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="."/>
							</xsl:otherwise>
						</xsl:choose>
					</instantiationDate>
				</xsl:for-each>
				<!-- formatPhysical: is this applicable in a mapping from a digital file analysis? -->
				<!-- formatDigital -->
				<xsl:if test="InternetMediaType">
					<instantiationDigital>
   						<xsl:attribute name="source"><xsl:value-of select="$mediainfoSource"/></xsl:attribute>
						<xsl:attribute name="version"><xsl:value-of select="$mediainfoVersion"/></xsl:attribute>
						<xsl:value-of select="InternetMediaType"/>
					</instantiationDigital>
				</xsl:if>
				<!-- formatStandard -->
				<xsl:if test="Format">
					<instantiationStandard>
   						<xsl:attribute name="profile"><xsl:value-of select="Format_Profile"/></xsl:attribute>
   						<xsl:attribute name="source"><xsl:value-of select="$mediainfoSource"/></xsl:attribute>
						<xsl:attribute name="version"><xsl:value-of select="$mediainfoVersion"/></xsl:attribute>
						<xsl:value-of select="Format"/>
					</instantiationStandard>
				</xsl:if>
				<!-- formatLocation -->
				<instantiationLocation><xsl:value-of select="CompleteName"/></instantiationLocation><!-- filepath -->
				<!-- formatMediaType -->
				<xsl:if test="string-length(VideoCount)>0 or string-length(AudioCount)>0 or string-length(ImageCount)>0 or string-length(TextCount)>0">
   					<instantiationMediaType>
	   					<xsl:attribute name="source">PBCore</xsl:attribute>
	   					<xsl:attribute name="version">1.1</xsl:attribute>
	   					<xsl:choose><!-- attempts to make a guess at formatMediaType. There is no method to clarify if a file is 'Animation' vs 'Moving Image', 'Presentation' vs 'Text', etc. Only these four mediaTypes are tested for now. -->
	   						<xsl:when test="VideoCount > 0">Moving Image</xsl:when>
	   						<xsl:when test="AudioCount > 0">Sound</xsl:when>
	   						<xsl:when test="ImageCount > 0">Static Image</xsl:when>
	   						<xsl:when test="TextCount  > 0">Text</xsl:when>
	   					</xsl:choose>
   					</instantiationMediaType>
   				</xsl:if>
				<!-- formatGenerations -->
				<!-- currently I don't make any assumptions here, pass in formatGenerations as stringparam -->
				<!--
				<xsl:if test="string-length($formatGenerations)>0">
   					<formatGenerations><xsl:value-of select="$formatGenerations"/></formatGenerations>
   					
				</xsl:if>
				-->
				<!-- formatFileSize -->
				<xsl:if test="FileSize"><!-- this expresses filesize as an integer count of bytes -->
					<instantiationFileSize>
						<xsl:attribute name="unitsOfMeasure">bytes</xsl:attribute>
						<xsl:value-of select="normalize-space(FileSize)"/>
   					</instantiationFileSize>
				</xsl:if>
				<!-- formatTimeStart -->
				<xsl:choose>
					<xsl:when test="Delay_Original_String3"><instantiationTimeStart><xsl:value-of select="Delay_Original_String3"/></instantiationTimeStart></xsl:when>
					<xsl:when test="Delay_String3"><instantiationTimeStart><xsl:value-of select="Delay_String3"/></instantiationTimeStart></xsl:when>
				</xsl:choose>
				<!-- formatDuration -->
				<xsl:if test="Duration_String3"><!-- expresses duration as HH:MM:SS.mmmm -->
					<instantiationDuration><xsl:value-of select="Duration_String3"/></instantiationDuration>
				</xsl:if>
				<!-- formatDataRate -->
				<xsl:if test="OverallBitRate"><!-- expresses bitrate as bits per second -->
					<instantiationDataRate>
   						<xsl:attribute name="unitsOfMeasure">bits/second</xsl:attribute>
   						<xsl:value-of select="OverallBitRate"/>
					</instantiationDataRate>
				</xsl:if>
				 	<!-- formatColors: undetermined, this value is about how the video color is presented, not stored -->			
				<!-- formatTracks -->
				<xsl:variable name='track'>
   					<xsl:if test="VideoCount">
	 						<xsl:value-of select="VideoCount"/><xsl:text> video track</xsl:text><xsl:if test="not(VideoCount='1')">s</xsl:if><xsl:text>, </xsl:text>
					</xsl:if>
					<xsl:if test="AudioCount">
	 						<xsl:value-of select="AudioCount"/><xsl:text> audio track</xsl:text><xsl:if test="not(AudioCount='1')">s</xsl:if><xsl:text>, </xsl:text>
					</xsl:if>
					<xsl:if test="TextCount">
	 						<xsl:value-of select="TextCount"/><xsl:text> text track</xsl:text><xsl:if test="not(TextCount='1')">s</xsl:if><xsl:text>, </xsl:text>
					</xsl:if>
				</xsl:variable>
				<instantiationTracks>
					<xsl:value-of select="substring($track,1,string-length($track)-2)"/>
				</instantiationTracks>				
				<!-- formatChannelConfiguration -->
				<xsl:if test="AudioCount>0"><!-- results aren't very interesting without audio configuration data -->
   					<xsl:variable name='fCC_audio'>
		   					<xsl:for-each select="../track[@type='Audio']"><xsl:value-of select="Format"/><xsl:if test='ChannelPositions'><xsl:text> (</xsl:text><xsl:value-of select="ChannelPositions"/><xsl:text>)</xsl:text></xsl:if><xsl:text>, </xsl:text></xsl:for-each>
   					</xsl:variable>
   					<xsl:variable name='fCC_text'>
		   					<xsl:for-each select="../track[@type='Text']"><xsl:value-of select="Format"/><xsl:if test='string-length(Language_String3)=3'><xsl:text> (</xsl:text><xsl:value-of select="Language_String3"/><xsl:text>)</xsl:text></xsl:if><xsl:text>, </xsl:text></xsl:for-each>
   					</xsl:variable>
   					<xsl:variable name='formatChannelConfigurations'>
	   					<xsl:if test="Video_Format_WithHint_List"><xsl:value-of select="Video_Format_WithHint_List"/> with </xsl:if>
   						<xsl:if test="Audio_Format_WithHint_List">
		 						<xsl:value-of select="substring($fCC_audio,1,string-length($fCC_audio)-2)"/><xsl:text> with </xsl:text>
   						</xsl:if>
   						<xsl:if test="Text_Format_WithHint_List">
	   						<xsl:value-of select="substring($fCC_text,1,string-length($fCC_text)-2)"/><xsl:text> with </xsl:text>
   						</xsl:if>
   						<xsl:if test="Image_Format_WithHint_List"><xsl:value-of select="Image_Format_WithHint_List"/> with </xsl:if>
   						<xsl:if test="Menu_Format_WithHint_List"><xsl:value-of select="Menu_Format_WithHint_List"/> with </xsl:if>
   					</xsl:variable>
   					<instantiationChannelConfiguration>
   						<xsl:value-of select="substring($formatChannelConfigurations,1,string-length($formatChannelConfigurations)-6)"/>
   					</instantiationChannelConfiguration>
				</xsl:if>
				<!-- language -->
   				<xsl:if test="string-length(Language_String3)=3">
   					<instantiationLanguage>
   						<xsl:value-of select="Language_String3"/>
   					</instantiationLanguage>
   				</xsl:if>
   				<!-- alternativeModes: nothing inferred here yet -->
   				<!-- essenceTrack -->
   				</xsl:for-each>
   				<xsl:for-each select="track[@type!='General']">
   				  <instantiationEssenceTrack>
   					<!-- essenceTrackType -->
   					<essenceTrackType>
	   					<xsl:choose><!-- some translation of reported trackType, else reported as is -->
	   						<xsl:when test="Format='TimeCode'">timecode</xsl:when>
	   						<xsl:when test="Format='EIA-608' or Format='EIA-708'">caption</xsl:when>
	   						<xsl:when test="../track[@type='Text']/Format='Apple text|ASS|DivX Subtitle|DVB Subtitles|PGS|SSA|Teletext|Text|Subrip|SubRip|Timed text|USF|VobSub'">subtitle</xsl:when>
	   						<xsl:when test="Format='CMML'">metadata</xsl:when>
	   						<xsl:when test="Format='Audio'">audio</xsl:when>
	   						<xsl:when test="Format='Video'">video</xsl:when>
	   						<xsl:otherwise><xsl:value-of select="@type"/></xsl:otherwise>
	   					</xsl:choose>
   					</essenceTrackType>
   					<!-- essenceTrackIdentifier/essenceTrackIdentifierSource -->
  						<xsl:if test="ID">
	  						<essenceTrackIdentifier>
		  						<xsl:attribute name="source">Mediainfo.ID</xsl:attribute>
		  						<xsl:value-of select="ID"/>
	  						</essenceTrackIdentifier>
  						</xsl:if>
  						<xsl:if test="StreamKindID">
	  						<essenceTrackIdentifier>
		  						<xsl:attribute name="source">Mediainfo.StreamKindID</xsl:attribute>
		  						<xsl:value-of select="StreamKindID"/>
	  						</essenceTrackIdentifier>
  				   		</xsl:if>
   				   	<!-- essenceTrackStandard -->
   					<xsl:if test="Standard">
   						<essenceTrackStandard><xsl:value-of select="Standard"/></essenceTrackStandard>
   					</xsl:if>
   					<!-- essenceTrackEncoding -->
   					<xsl:if test="Format"><!-- not sure how best to handle encoding, feel free to remove the extra xsl:if statements to reduce verbosity -->
   						<xsl:variable name="encoding">
	   						<xsl:if test="Format_Version">
	   							<xsl:value-of select="Format_Version"/>
	   						</xsl:if>
	   						<xsl:if test="Format_Commercial_IfAny">
	   							<xsl:text> </xsl:text><xsl:value-of select="Format_Commercial_IfAny"/>
	   						</xsl:if>
	   						<xsl:if test="Format_Profile">
	   							<xsl:text> </xsl:text><xsl:value-of select="Format_Profile"/>
	   						</xsl:if>
	   						<xsl:if test="Format_Settings_Endianness">
	   							<xsl:text> </xsl:text><xsl:value-of select="Format_Settings_Endianness"/><xsl:text>-endian</xsl:text>
	   						</xsl:if>
	   						<xsl:if test="Format_Settings_Sign">
	   							<xsl:text> </xsl:text><xsl:value-of select="Format_Settings_Sign"/>
	   						</xsl:if>
   						</xsl:variable>
   						<essenceTrackEncoding>
	 						<xsl:if test="string-length($encoding)>0 or string-length(CodecID)>0">
		 						<xsl:attribute name="ref"><xsl:value-of select="CodecID"/></xsl:attribute>
		 						<xsl:attribute name="annotation"><xsl:value-of select="normalize-space(CodecID_Hint)"/></xsl:attribute>
		 						<xsl:choose>
			 						<xsl:when test="string-length($encoding)>0">
				 						<xsl:value-of select="$encoding"/>
			 						</xsl:when>
		   							<xsl:otherwise>
			   							<xsl:value-of select="CodecID"/>
		   							</xsl:otherwise>
	   							</xsl:choose>
	   						</xsl:if>
   						</essenceTrackEncoding>
   					</xsl:if>
   					<!-- essenceTrackDataRate -->
   					<xsl:if test="BitRate">
   						<essenceTrackDataRate>
	   						<xsl:attribute name="unitsOfMeasure">bits/second</xsl:attribute>
	   						<xsl:attribute name="annotation"><xsl:value-of select="BitRate_Mode"/></xsl:attribute>
	   						<xsl:value-of select="BitRate"/>
	  						</essenceTrackDataRate>
   					</xsl:if>
   					<!-- essenceTrackFrameRate -->
	 				<xsl:if test="FrameRate">
		  				<essenceTrackFrameRate>
			  				<xsl:if test="FrameRate_Original">
				  				<xsl:attribute name="annotation">
					  				<xsl:text>Frame rate of codec:</xsl:text><xsl:value-of select="FrameRate_Original"/><xsl:text> fps</xsl:text>
				 				</xsl:attribute>
			  				</xsl:if>
			  				<xsl:value-of select="FrameRate"/><xsl:text> fps</xsl:text>
		  				</essenceTrackFrameRate>
	 				</xsl:if>
	 				<!-- essenceTrackSamplingRate -->
   					<xsl:if test="SamplingRate">
   						<essenceTrackSamplingRate><xsl:value-of select="SamplingRate div 1000"/><xsl:text> kHz</xsl:text></essenceTrackSamplingRate>
   					</xsl:if>
   					<!-- essenceTrackBitDepth -->
   					<xsl:if test="BitDepth">
   						<essenceTrackBitDepth><xsl:value-of select="BitDepth"/><xsl:text> bit</xsl:text></essenceTrackBitDepth>
   					</xsl:if>
   					<!-- essenceTrackFrameSize -->
   					<xsl:if test="Width">
   						<essenceTrackFrameSize>
   						<xsl:choose>
		  						<xsl:when test="Width_Original">
									<xsl:value-of select="Width_Original"/>
	   						</xsl:when>
	   						<xsl:otherwise>
			  						<xsl:value-of select="Width"/>
	   						</xsl:otherwise>
   						</xsl:choose>
   						<xsl:text>x</xsl:text>
		  					<xsl:choose>
		  						<xsl:when test="Height_Original">
									<xsl:value-of select="Height_Original"/>
	   						</xsl:when>
	   						<xsl:otherwise>
			  						<xsl:value-of select="Height"/>
	   						</xsl:otherwise>
   						</xsl:choose>
   						</essenceTrackFrameSize>
   					</xsl:if>
   					<!-- essenceTrackAspectRatio: as displayed not stored -->
   					<xsl:if test="DisplayAspectRatio_String">
   						<essenceTrackAspectRatio><xsl:value-of select="DisplayAspectRatio_String"/></essenceTrackAspectRatio>
   					</xsl:if>
   					<!-- essenceTrackTimeStart -->
   					<xsl:choose>
   						<xsl:when test="Delay_Original_String3">
   							<essenceTrackTimeStart><xsl:value-of select="Delay_Original_String3"/></essenceTrackTimeStart>
   						</xsl:when>
   						<xsl:when test="Delay_String3">
   							<essenceTrackTimeStart><xsl:value-of select="Delay_String3"/></essenceTrackTimeStart>
   						</xsl:when>
   					</xsl:choose>
   					<!-- essenceTrackDuration -->
   					<xsl:if test="Duration_String3">
   						<essenceTrackDuration><xsl:value-of select="Duration_String3"/></essenceTrackDuration>
   					</xsl:if>
   					
   					<!-- essenceTrackLanguage -->
   					<xsl:if test="string-length(Language_String3)=3">
   						<essenceTrackLanguage>
   							<xsl:value-of select="Language_String3"/>
   						</essenceTrackLanguage>
   					</xsl:if>
   					<!-- essenceTrackAnnotation -->
	 					<!-- the following potential annotations from MediaInfo are renamed for PBCore -->
	 					<xsl:if test="Channel_s_">
	 						<essenceTrackAnnotation>
		 						<xsl:attribute name="annotationType">Channels</xsl:attribute>
		 						<xsl:value-of select="Channel_s_"/>
								</essenceTrackAnnotation>
	 					</xsl:if>
	 					<xsl:if test="Bits-_Pixel_Frame_">
	 						<essenceTrackAnnotation>
		 						<xsl:attribute name="annotationType">BitsPerPixel</xsl:attribute>
		 						<xsl:value-of select="Bits-_Pixel_Frame_"/>
								</essenceTrackAnnotation>
	 					</xsl:if>
	 					<xsl:if test="Delay_Settings"><!-- note occasionally a codec and container can have conflicting timecode setting data -->
			 				<essenceTrackAnnotation>
		 						<xsl:attribute name="annotationType">TimecodeSettings_Container</xsl:attribute>
		 						<xsl:value-of select="Delay_Settings"/>
								</essenceTrackAnnotation>
	 					</xsl:if>
	 					<xsl:if test="Delay_Original_Settings">
	 						<essenceTrackAnnotation>
		 						<xsl:attribute name="annotationType">TimecodeSettings_Codec</xsl:attribute>
		 						<xsl:value-of select="Delay_Original_Settings"/>
								</essenceTrackAnnotation>
	 					</xsl:if>
	 
	 					<!-- unlike annotations of the instantiation element, the essenceTrackAnnotation may only occur once per essenceTrack. This approach excludes MediaInfo values that are mapped elsewhere, depreciated, or redundant and then states the remaining essenceTrack values in a concatenated string within a single essenceTrack element with line breaks separating each value. This produces a very verbose reporting on essenceTrack data. -->
 						<xsl:for-each select="*">
 							<xsl:if test="name(.)!='Count' and name(.)!='StreamCount' and name(.)!='StreamKind' and name(.)!='StreamKind_String' and name(.)!='StreamKindID' and name(.)!='StreamKindPos' and name(.)!='Inform' and name(.)!='ID' and name(.)!='ID_String' and name(.)!='Format_Info' and name(.)!='Format_URL' and name(.)!='Format_Settings_SBR_String' and name(.)!='Format_Settings_PS_String' and name(.)!='Format_Version' and name(.)!='Format_Profile' and name(.)!='CodecID_Info' and name(.)!='CodecID_Hint' and name(.)!='CodecID_Url' and name(.)!='CodecID_Description' and name(.)!='Codec' and name(.)!='Codec_String' and name(.)!='Codec_Family' and name(.)!='Codec_Info' and name(.)!='Codec_Url' and name(.)!='Codec_CC' and name(.)!='Codec_Profile' and name(.)!='Codec_Description' and name(.)!='Codec_Profile' and name(.)!='Codec_Settings' and name(.)!='Codec_Settings_Automatic' and name(.)!='Codec_Settings_Floor' and name(.)!='Codec_Settings_Firm' and name(.)!='Codec_Settings_Endianness' and name(.)!='Codec_Settings_Sign' and name(.)!='Codec_Settings_Law' and name(.)!='Codec_Settings_ITU' and name(.)!='Codec_Settings_BVOP' and name(.)!='Codec_Settings_QPel' and name(.)!='Codec_Settings_GMC' and name(.)!='Codec_Settings_GMC_String' and name(.)!='Codec_Settings_Matrix' and name(.)!='Codec_Settings_Matrix_Data' and name(.)!='Codec_Settings_CABAC' and name(.)!='Codec_Settings_RefFrames' and name(.)!='Duration' and name(.)!='Duration_String' and name(.)!='Duration_String1' and name(.)!='Duration_String2' and name(.)!='Duration_String3' and name(.)!='BitRate_Mode_String' and name(.)!='BitRate' and name(.)!='BitRate_String' and name(.)!='lBitRate_Minimum_String' and name(.)!='BitRate_Nominal_String' and name(.)!='BitRate_Maximum_String' and name(.)!='Channel_s__String' and name(.)!='ChannelPositions_String2' and name(.)!='SamplingRate' and name(.)!='SamplingRate_String' and name(.)!='Width' and name(.)!='Width_Original' and name(.)!='Width_Original_String' and name(.)!='Width_String' and name(.)!='Height' and name(.)!='Height_Original' and name(.)!='Height_Original_String' and name(.)!='Height_String' and name(.)!='PixelAspectRatio_String' and name(.)!='PixelAspectRatio_Original_String' and name(.)!='DisplayAspectRatio_String' and name(.)!='DisplayAspectRatio_Original_String' and name(.)!='FrameRate' and name(.)!='FrameRate_String' and name(.)!='FrameRate_Minimum_String' and name(.)!='FrameRate_Nominal_String' and name(.)!='FrameRate_Maximum_String' and name(.)!='FrameRate_Original_String' and name(.)!='Resolution' and name(.)!='Resolution_String' and name(.)!='ScanType_String' and name(.)!='ScanOrder_String' and name(.)!='Interlacement' and name(.)!='Interlacement_String' and name(.)!='Delay' and name(.)!='Delay_String' and name(.)!='Delay_String1' and name(.)!='Delay_String2' and name(.)!='Delay_String3' and name(.)!='Delay_Original' and name(.)!='Delay_Original_String' and name(.)!='Delay_Original_String1' and name(.)!='Delay_Original_String2' and name(.)!='Delay_Original_String3' and name(.)!='Video_Delay' and name(.)!='Video_Delay_String' and name(.)!='Video_Delay_String1' and name(.)!='Video_Delay_String2' and name(.)!='Video_Delay_String3' and name(.)!='Video0_Delay' and name(.)!='Video0_Delay_String' and name(.)!='Video0_Delay_String1' and name(.)!='Video0_Delay_String2' and name(.)!='Video0_Delay_String3' and name(.)!='ReplayGain_Gain_String' and name(.)!='Interleave_Duration_String' and name(.)!='Interleave_Preload_String' and name(.)!='StreamSize_String' and name(.)!='StreamSize_String1' and name(.)!='StreamSize_String2' and name(.)!='StreamSize_String3' and name(.)!='StreamSize_String4' and name(.)!='StreamSize_String5' and name(.)!='Alignment_String' and name(.)!='Encoded_Application_Url' and name(.)!='Encoded_Library_String' and name(.)!='Language' and name(.)!='Language_String' and name(.)!='Language_String1' and name(.)!='Language_String2' and name(.)!='Language_String3' and name(.)!='Language_String4' and name(.)!='Colorimetry' and name(.)!='Format' and name(.)!='Format_Settings' and name(.)!='Format_Settings_Endianness' and name(.)!='Format_Settings_Sign' and name(.)!='InternetMediaType' and name(.)!='CodecID' and name(.)!='Standard' and name(.)!='FolderName' and name(.)!='Channel_s_' and name(.)!='FrameRate_Mode_String' and name(.)!='Bits-_Pixel_Frame_' and name(.)!='Delay_Settings' and name(.)!='Delay_Original_Settings' and name(.)!='MenuID_String' and name(.)!='Format_Url' and name(.)!='Format_Settings_CABAC_String' and name(.)!='Format_Settings_RefFrames_String' and name(.)!='FrameRate_Mode_String' and name(.)!='Encoded_Library' and name(.)!='Format_Commercial' and name(.)!='Format_Commercial_IfAny' and name(.)!='BitDepth' and name(.)!='BitDepth_String'">			   
							   		<essenceTrackAnnotation>
		 					   		<xsl:attribute name="annotationType">
			 					   		<xsl:value-of select="local-name(.)"/>
		 					   		</xsl:attribute>
										<xsl:choose>
											<xsl:when test="substring(.,1,3)='UTC' and string-length(.)='23'">
												<xsl:value-of select="substring(.,5,10)"/><xsl:text>T</xsl:text><xsl:value-of select="substring(.,16,8)"/><xsl:text>Z</xsl:text>
											</xsl:when>
											<xsl:when test="string-length(.)='19'">
												<xsl:value-of select="substring(.,1,10)"/><xsl:text>T</xsl:text><xsl:value-of select="substring(.,12,8)"/>
											</xsl:when>
											<xsl:otherwise>
												<xsl:value-of select="."/>
											</xsl:otherwise>
										</xsl:choose>
									</essenceTrackAnnotation>
								</xsl:if>
							</xsl:for-each>
	  				  </instantiationEssenceTrack>
	  				</xsl:for-each>
	   				
			<!-- annotations: there seems to be 2 ways to go about handling annotations in a MediaInfo to pbcore-instantiation workflow: 1). inclusive and 2). exclusive. The below method goes with an exclusive approach where MediaInfo values that aren't specifically mapped elsewhere are retained while depreciated and redundant values are also excluded. Feel free to tinker with the test attribute in the xsl:if element to adjust the verbosity. An alternate inclusive approach is commented out just below this. -->
   				<xsl:for-each select="track[@type='General']">
	   				<!-- instantiationRelations -->
	  				<xsl:for-each select="str:tokenize(Media_History_UUID, '/')">
						<instantiationRelation>
							<instantiationRelationType>Is Derived From</instantiationRelationType>
							<instantiationRelationIdentifier>
	   							<xsl:attribute name="source">Final Cut UUID</xsl:attribute>
	   							<xsl:attribute name="ref">com.apple.finalcutstudio.media.uuid</xsl:attribute>
	   							<xsl:value-of select="normalize-space(.)"/>
			   				</instantiationRelationIdentifier>
						</instantiationRelation>
					</xsl:for-each>
					<xsl:for-each select="str:tokenize(OriginalSourceMedium, '/')"><!-- this matches the value 'Reel' in Final Cut, it's stored as a label on a Quicktime timecode track -->
						<instantiationRelation>
							<instantiationRelationType>Is Digitized From</instantiationRelationType>
							<instantiationRelationIdentifier>
	   							<xsl:attribute name="source">Original Source Medium</xsl:attribute>
	   							<xsl:value-of select="normalize-space(.)"/>
			   				</instantiationRelationIdentifier>
						</instantiationRelation>
					</xsl:for-each>
   					<xsl:if test="Format">
   						<instantiationAnnotation>
   						   		<xsl:attribute name="annotationType">Container</xsl:attribute>
   						   		<xsl:value-of select="Format"/>
   						   		<xsl:if test="Format_Version">
   									<xsl:text> </xsl:text><xsl:value-of select="Format_Version"/>
   								</xsl:if>
   								<xsl:if test="Format_Profile">
   									<xsl:text> </xsl:text><xsl:value-of select="Format_Profile"/>
   								</xsl:if>
   							   	<xsl:if test="CodecID"><!-- fourcc codes are helpful but don't have an explicit location in pbcore. Current these are stored parathetically within essenceTrackEncoding and 'Container' annotations but potentially these could be handled separately as their own annotation. -->
   									<xsl:text> (</xsl:text><xsl:value-of select="CodecID"/><xsl:text>)</xsl:text>
   								</xsl:if>
   						</instantiationAnnotation>
   					</xsl:if>
   					<xsl:for-each select="*">
   						<xsl:if test="name(.)!='Count' and name(.)!='StreamCount' and name(.)!='StreamKind' and name(.)!='StreamKind_String' and name(.)!='StreamKindID' and name(.)!='StreamKindPos' and name(.)!='Inform' and name(.)!='ID_String' and name(.)!='UniqueID_String' and name(.)!='GeneralCount' and name(.)!='VideoCount' and name(.)!='AudioCount' and name(.)!='TextCount' and name(.)!='ChaptersCount' and name(.)!='ImageCount' and name(.)!='MenuCount' and name(.)!='Video_Format_List' and name(.)!='Video_Language_List' and name(.)!='Video_Format_WithHint_List' and name(.)!='Video_Codec_List' and name(.)!='Audio_Format_List' and name(.)!='Audio_Language_List' and name(.)!='Audio_Format_WithHint_List' and name(.)!='Audio_Codec_List' and name(.)!='Text_Format_List' and name(.)!='Text_Language_List' and name(.)!='Text_Format_WithHint_List' and name(.)!='Text_Codec_List' and name(.)!='Chapters_Format_List' and name(.)!='Chapters_Language_List' and name(.)!='Chapters_Format_WithHint_List' and name(.)!='Chapters_Codec_List' and name(.)!='Image_Format_List' and name(.)!='Image_Language_List' and name(.)!='Image_Format_WithHint_List' and name(.)!='Image_Codec_List' and name(.)!='Menu_Format_List' and name(.)!='Menu_Language_List' and name(.)!='Menu_Format_WithHint_List' and name(.)!='Menu_Codec_List' and name(.)!='FileName' and name(.)!='Format' and name(.)!='Format_Extensions' and name(.)!='Format_Version' and name(.)!='Format_Profile' and name(.)!='Format_String' and name(.)!='Format_Url' and name(.)!='CodecID' and name(.)!='Codec' and name(.)!='Codec_String' and name(.)!='Codec_Info' and name(.)!='Codec_Url' and name(.)!='CodecID_Url' and name(.)!='Codec_Extensions' and name(.)!='Codec_Settings' and name(.)!='Codec_Settings_Automatic' and name(.)!='OriginalSourceMedium' and name(.)!='com.apple.finalcutstudio.media.uuid' and name(.)!='CompleteName' and name(.)!='FileSize' and name(.)!='FileSize_String' and name(.)!='FileSize_String1' and name(.)!='FileSize_String2' and name(.)!='FileSize_String3' and name(.)!='FileSize_String4' and name(.)!='Delay_Original_String3' and name(.)!='Delay_String3' and name(.)!='Duration' and name(.)!='Duration_String' and name(.)!='Duration_String1' and name(.)!='Duration_String2' and name(.)!='Duration_String3' and name(.)!='OverallBitRate_Mode_String' and name(.)!='OverallBitRate' and name(.)!='OverallBitRate_String' and name(.)!='OverallBitRate_Minimum_String' and name(.)!='OverallBitRate_Nominal_String' and name(.)!='OverallBitRate_Maximum_String' and name(.)!='StreamSize' and name(.)!='StreamSize_Proportion' and name(.)!='StreamSize_String' and name(.)!='StreamSize_String1' and name(.)!='StreamSize_String2' and name(.)!='StreamSize_String3' and name(.)!='StreamSize_String4' and name(.)!='StreamSize_String5' and name(.)!='com.apple.quicktime.player.movie.audio.mute' and name(.)!='Encoded_Library_String' and name(.)!='Encoded_Library_Name' and name(.)!='Encoded_Library_Version' and name(.)!='Cover_Data' and name(.)!='Language' and name(.)!='Language_String' and name(.)!='Language_String1' and name(.)!='Language_String2' and name(.)!='Language_String3' and name(.)!='Language_String4' and name(.)!='InternetMediaType' and name(.)!='FileExtension' and name(.)!='Media_UUID' and name(.)!='Media_History_UUID' and name(.)!='FolderName' and name(.)!='Format_Commercial' and name(.)!='Format_Commercial_IfAny'">
   							<instantiationAnnotation>	  		
  								   	<xsl:attribute name="annotationType"><xsl:value-of select="local-name(.)"/></xsl:attribute>					
  									<xsl:choose>
  										<xsl:when test="substring(.,1,3)='UTC' and string-length(.)='23'">
  											<xsl:value-of select="substring(.,5,10)"/><xsl:text>T</xsl:text><xsl:value-of select="substring(.,16,8)"/><xsl:text>Z</xsl:text>
  										</xsl:when>
  										<xsl:when test="string-length(.)='19'">
	  										<xsl:value-of select="substring(.,1,10)"/><xsl:text>T</xsl:text><xsl:value-of select="substring(.,12,8)"/>
  										</xsl:when>
  										<xsl:otherwise>
  											<xsl:value-of select="."/>
  										</xsl:otherwise>
  									</xsl:choose>
   							</instantiationAnnotation>
   						</xsl:if>
   					</xsl:for-each>
   				</xsl:for-each>
	</xsl:template>	
</xsl:stylesheet>